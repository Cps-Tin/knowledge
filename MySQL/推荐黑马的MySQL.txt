https://www.bilibili.com/video/BV1Kr4y1i7ru


MySQL-基础篇
MySQL-进阶篇
MySQL-运维篇



前缀索引：https://blog.csdn.net/wdjnb/article/details/122880079




前缀索引：https://blog.csdn.net/wdjnb/article/details/122880079
	
	5.索引叶子结点上数据之间是有单向链表维系的，所以接着第一步查找的结果，继续向后读取下一条记录，然后重复 2、3、4 步，直到在 user_uuid_index 上取到的值不为 39352f81-1 时，循环结束。

	如果我们建立了前缀索引并且前缀索引的选择性为 1，那么就不需要第 5 步了，如果前缀索引选择性小于 1，就需要第五步。


B+Tree

	树左侧：小于等于
	树右侧：大于

	下方：形成链表，索引叶子结点上数据之间是有单向链表维系的，所以接着第一步查找的结果x，继续向后读取下一条记录，然后重复 2、3、4 步，直到在 user_uuid_index 上取到的值不为x 输入的值时，循环结束。


为什么MySQL默认可重复读，而大多数数据库(Oracle、SQLServer)是读已提交，参考：https://blog.51cto.com/u_15485936/5202149


我们都知道事务的几种性质 :原子性、一致性、隔离性和持久性 (ACID)
为了维持一致性和隔离性,一般使用加锁这种方式来处理,但是加锁相对带来的是并发处理能力的降低

可重复读(Repeated Read)：可重复读。基于锁机制并发控制的DBMS需要对选定对象的读锁(read locks)和写锁(write locks)一直保持到事务结束，但不要求“范围锁(range-locks)”，因此可能会发生“幻影读(phantom reads)” 在该事务级别下，保证同一个事务从开始到结束获取到的数据一致。是Mysql的默认事务级别。

读已提交，binlog如果是statement模式，就可能会出现从库同步问题(需要加入间隙锁)，或者5.1之后使用row模式同步