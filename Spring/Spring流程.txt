

UserSerive类--->无参的构造方法--->对象--->放入Map单例池--->Bean对象

UserSerive类--->无参的构造方法--->对象--->依赖注入--->放入Map单例池--->Bean对象

UserSerive类--->无参的构造方法--->对象--->依赖注入--->初始化前--->初始化--->初始化后--->放入Map单例池--->Bean对象

UserSerive类--->无参的构造方法--->对象--->依赖注入--->初始化前(@PostConstruct)--->初始化--->初始化后--->放入Map单例池--->Bean对象

UserSerive类--->无参的构造方法--->对象--->依赖注入--->初始化前(@PostConstruct)--->初始化(InitializingBean)--->初始化后--->放入Map单例池--->Bean对象

UserSerive类--->无参的构造方法--->对象--->依赖注入--->初始化前(@PostConstruct)--->初始化(InitializingBean)--->初始化后(AOP)--->放入Map单例池--->Bean对象

UserSerive类--->无参的构造方法--->普通对象--->依赖注入--->初始化前(@PostConstruct)--->初始化(InitializingBean)--->初始化后(AOP)--->代理对象--->放入Map单例池--->Bean对象

UserSerive类--->推断的构造方法--->普通对象--->依赖注入--->初始化前(@PostConstruct)--->初始化(InitializingBean)--->初始化后(AOP)--->代理对象--->放入Map单例池--->Bean对象


推断的构造方法：
	1.没有无参，多个有参，需要使用@Autowired指定构造方法
	2.有参构造方法的入参是对象时，spring会先根据byType找，如果找到多个再根据byName匹配，没有找到会自己创建一个，但这里就是循环依赖的起始


依赖注入：
	1.获取该对象中的所有属性，判断含有@Autowired的属性会注入，注入方式和上方有参构造方式一样


代理对象（CJLIB）	

	父子类

		UserServiceProxy对象--->UserService代理对象--->Uservice代理对象.target=普通对象，放入Map单例池，也就是说代理对象之后没有再经过依赖注入，所以orderService属性是空的

		UserService代理对象.test()

		class UserServiceProxy extends UserService {

			// 这里是空，因为代理对象没有经历过依赖注入
			OrderService orderService;

			// Uservice代理对象.target=普通对象
			UserService target;

			public void test() {
				// @Before切面逻辑
				// 是否含有@Transactional注解，有的话关闭自动提交
				// conn.autocommit = false
				// target.test(); // 普通对象.test() sql1 sql2 sql3
				// conn.commit(); conn.rollback();
			}


		}





AService创建生命周期

0.creatingSet("AService")
1.创建一个AService普通对象--->singletonFactories<aService, lambda>
2.填充bService属性--->去单例池中找BService对象--->创建BService的Bean对象
2.填充cService属性--->去单例池中找CService对象--->创建CService的Bean对象
3.填充其他属性
4.其他操作
5.初始化后（AOP）---> earlyProxyReferences 判断是否创建过AOP的对象，创建过则不需要再创建
5.5.earlySingletonobjects从二级缓存取不完整的Bean，singletonFactories移除对象(每个lambda取一次，执行一次就够了，单例情况)
6.放入单例池


Bservice创建生命周期

1.创建一个BService普通对象
2.填充aService属性--->去单例池中找AService对象--->creatingSet(循环依赖)--->先从二级取earlySingletonObjects--->没有再从三级取，这里一定会有，singletonFactories.getObject()执行lambda表达式(返回AService[代理/普通]对象)--->把这个lambda表达式结果放入earlySingletonObjects<aService, Aservice代理对象/普通对象>
3.填充其他属性
4.其他操作
5.初始化后
6.放入单例池


Cservice创建生命周期

1.创建一个Bservice普通对象
2.填充aService属性--->去单例池中找AService对象--->creatingSet-->出现循环依赖--->earlySingletonObjects(存在取出)--->AServvice代理对象
3.填充其他属性
4.其他操作
5.初始化
6.放入单例池



建议参考下这篇文档：https://blog.csdn.net/wujun2412/article/details/123392678

Spring解决循环依赖的理论依据其实是基于Java的引用传递，当我们获取到对象的引用时，对象的field或则属性是可以延后设置的(但是构造器必须是在获取引用之前)。


1.第一级缓存 	singletonobjects 						单例池，保存实例化、注入、初始化完成的bean实例
2.第二级缓存 	earlySingletonobjects 					保存实例化完成的bean实例，防止cService重复创建AService代理对象
3.第三级缓存 	singletonFactories<aService, lambda>	保存bean创建工厂，以便于后面扩展有机会创建代理对象


循环依赖条件：单例池中没有，creatingSet自己正在创建中


完整对象创建分两个步骤：实例化 + 初始化，只要初始化没进行完毕，就不完整
对象分三种类型：刚实例化的普通对象（放在三级缓存），提前进行AOP的不完整对象（放在二级缓存），完整对象（一级缓存/单例池）

循坏依赖带来了什么问题？重复创建，如何解决？第三级缓存通过存储刚创建的实例化普通对象来打破循环，但循环依赖需要的是完成了AOP的代理对象，所以将三级缓存中的对象取出，提前进行AOP并放入二级缓存

那为什么要二级缓存？因为需要区分“已进行AOP的不完整对象”和“完整的代理对象”，并防止多次AOP（多个循环依赖叠加可导致）




